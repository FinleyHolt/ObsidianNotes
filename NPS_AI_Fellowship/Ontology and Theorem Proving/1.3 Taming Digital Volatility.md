> What sorts of computer software systems can benefit from an ontology?
> During my work with Los Alamos and Argonne National Labs while in grad school, we worked on ontologies in order to improve the data governance of x-ray diffraction synchrotron experiments. As researchers when to the synchrotrons, they would receive metadata from the experiments in various formats (hand-written notes, csv, json) and would have difficulties understanding what fields meant after they had left the laboratory and returned to their institutions to analyze the results of the experiments. Building an ontology enabled us to build a shared understanding across different beam lines and laboratories which both improves communication between scientists as well as between computers as we begin to apply machine learning techniques to datasets that now container richer metadata.

How do programmers/IT professionals communicate about what their data elements mean?
* What are the current methods?
* What are the risks?
* What can we do about it?

Solutions?
* Talk to the developer
	* What if he or she is in another country or timezone?
	* Left the company?
* Read the code
	* Which code if many different systems access the data?
	* What if different programs disagree?
* Read the documentation
	* May not exist/be good 

Small Standards
* People can read the whole standard.
* Some people can remember the whole standard.
* As the standard evolves, people can catch inconsistencies.
Big Standards
* People probably can't read the whole standard.
* No one can remember the whole standard.
* As the standard evolves, inconsistences are missed.

![[Pasted image 20251213154236.png|400]]]

 Modern Programming
 * Expressive languages
	 * Procedural programming languages must be Turing complete
	 * Declarative language have gradations of expressiveness
 * Large and reusable libraries
	 * Java has 5000 built-in classes, and 100k in external libraries
	 * Only 3-5% of code in one study is new

Proof
* When your concepts have computable definitions automation can show they are correct and consistent.

Resources
* All open source
	* Library of concepts and definitions
	* Development tools
	* Logical language
	* Theorum provers
	* Lexicons
	* Textbook
* About the same effort to learn as a new programming language

Enabling Features for Managing Volatiliy
* An expressive computable language
	* So any definition can be stated
	* If it isn't computable, a computer can't help much
* A large library of definitions
	* So many important distinctions have already been carefully worked out*